<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-用RxJava实现一个ImageLoader" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/11/用RxJava实现一个ImageLoader/" class="article-date">
  <time datetime="2017-04-11T06:37:39.273Z" itemprop="datePublished">2017-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/11/用RxJava实现一个ImageLoader/">用RxJava实现一个ImageLoader</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在看这篇文章已经假设你对RxJava有了一点点了解，如果你都不知道RxJava是啥，<a href="http://gank.io/post/560e15be2dca930e00da1083#toc_15%20%E6%88%B3%E6%88%91" target="_blank" rel="external">戳我</a>，这篇文章是RxJava入门很好的资料。</p>
<p>RxJava的流式编程方式确实让有些复杂的代码简化不少，提高了代码的可阅读性，后期维护起来自然也方便很多。一开始只是看RxJava的文档确实很抽象，面对一大堆操作符，各种不知道什么鬼东西的概念，看的云里雾里的，内心一万头草泥马奔过，摔！所以还是做一个Demo来学习是比较高效的学习方式。</p>
<p>在这个前提下，我就开始着手写了一个ImageLoader。之所以是做ImageLoader，是因为最近也正好在看主席的《Android开发艺术探索》，其中一章正好是实现了一个ImageLoader，书里的实现方式是线程池和Handler，耗时的加载图片任务在线程池中执行，执行完成后发送消息到Handler，给ImageView设置图片在主线程中完成。基本设计思路和AsyncTask一致，对这块不懂的可以去看下AsyncTask的源码，在此就不展开分析了，善用搜索。</p>
<p>这种类似AsyncTask的实现看着代码很繁琐，用RxJava来代替Handler和线程池实现线程切换和异步加载便捷很多，代码的逻辑看起来也舒服多了。</p>
<p>在贴上代码之前还是先讲下ImageLoader实现的大体思路吧，首先加载图片需要内存缓存和磁盘缓存功能，分别使用了LruCache和DiskLruCache，并且需要图片压缩的功能，压缩功能是BitmapFactory解析bitmap时通过更改Options中的inSampleSize(采样率)实现的。加载图片入口方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void bindImage(ImageView imageView, String url, int reqWidth, int reqHeight) &#123;</div><div class="line">     String key = hashKeyFormUrl(url);</div><div class="line">     try &#123;</div><div class="line">         if (mLruCache.get(key) != null) &#123;</div><div class="line">             bindImageFromMemo(imageView, key); //从内存缓存中加载</div><div class="line">         &#125;</div><div class="line">         if (mDiskLruCache.get(key) != null) &#123;</div><div class="line">             bindImageFromDisk(imageView, key, reqWidth, reqHeight); //从磁盘缓存中加载</div><div class="line">         &#125; else &#123;</div><div class="line">             downloadImageFromHttp(imageView, url, reqWidth, reqHeight);  //从网络下载图片</div><div class="line">         &#125;</div><div class="line">     &#125; catch (IOException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>想必不用过多解释这个加载流程了吧，依次从内存缓存，磁盘缓存，网络加载图片。这里以从网络加载图片代码逻辑为例，对比使用RxJava和不使用的区别，大家自行感受区别。代码具体逻辑是从网络加载图片，并将下载好的图片存储到磁盘缓存中，并且将压缩过的bitmap设置给imageview。。首先演示使用线程池加Handler的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">    private Handler mHandler = new Handler(getMainLooper())&#123;//主线程中的Handler，作用是切换线程，在这里是将线程池中执行完毕返回的bitmap等封装好的对象发送到主线程中处理</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            if(msg.what == MESSAGE_POST_RESULT)&#123;</div><div class="line">	            Result result = (Result)msg.obj;</div><div class="line">		        ImageView imageview = result.imageview;</div><div class="line">		        String url = result.url;</div><div class="line">		        Bitmap bitmap = result.bitmap;</div><div class="line">		        if(url.equals((String)imageview.getTag(R.id.imageloader_id)))&#123;//防止图片错位</div><div class="line">				       imageview.setImageBitmap(bitmap);</div><div class="line">		        &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">private void downloadImageFromHttp(final ImageView imageView, final String url, final int reqWidth, final int reqHeight) &#123;</div><div class="line">        imageView.setTag(R.id.imageloader_id, url);</div><div class="line">        THREAD_POOL_EXECUTOR.execute(//在线程池中执行下载任务，执行完成后发送消息</div><div class="line">                new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">		               InputStream inputStream = new URL(s).openStream();</div><div class="line">                       saveBitmapToDisk(inputStream, hashKeyFormUrl(url));  </div><div class="line">                       Bitmap bitmap = getBitmapFromDisk(hashKeyFormUrl(url),reqWidth,reqHeight);</div><div class="line">                       mHandler.obtainMessage(MESSAGE_POST_RESULT,new Result(imageView,url,bitmap)).setToTarget();</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>以上省去了线程池配置代码，代码逻辑还是有点绕的，而且代码量也不少，对于不是很熟悉Handler和线程池的盆友可能写着写着就绕晕了，所以这里强烈推荐使用RxJava来实现以上功能，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private void downloadImageFromHttp(final ImageView imageView, final String url, final int reqWidth, final int reqHeight) &#123;</div><div class="line">       imageView.setTag(R.id.imageloader_id, url);</div><div class="line">       Observable.just(url)</div><div class="line">               .flatMap(new Func1&lt;String, Observable&lt;Bitmap&gt;&gt;() &#123;</div><div class="line">                   @Override</div><div class="line">                   public Observable&lt;Bitmap&gt; call(String s) &#123;</div><div class="line">                       InputStream inputStream = null;</div><div class="line">                       try &#123;</div><div class="line">                           inputStream = new URL(s).openStream();</div><div class="line">                           saveBitmapToDisk(inputStream, hashKeyFormUrl(url));</div><div class="line">                       &#125; catch (IOException e) &#123;</div><div class="line">                           e.printStackTrace();</div><div class="line">                       &#125; finally &#123;</div><div class="line">                           return Observable.just(getBitmapFromDisk(hashKeyFormUrl(url), reqWidth, reqHeight));</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;)</div><div class="line">               .subscribeOn(Schedulers.io())</div><div class="line">               .observeOn(AndroidSchedulers.mainThread())</div><div class="line">               .subscribe(new Action1&lt;Bitmap&gt;() &#123;</div><div class="line">                   @Override</div><div class="line">                   public void call(Bitmap bitmap) &#123;</div><div class="line">                       if (imageView.getTag(R.id.imageloader_id) == url) &#123;</div><div class="line">                           imageView.setImageBitmap(bitmap);</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>直观来看，代码从上到下，一气呵成，不用线程池繁琐的配置，没有handler线程切换等操作，像穿珠子一样，逻辑从头到尾都是一条线。</p>
<p>首先just操作符接收了传入的url，接下来flatmap进行数据的变换操作，通过url获取输入流，并且将其解析成bitmap存储到磁盘缓存中，然后再从磁盘缓存中读取刚写入的bitmap，并且最终将读取的bitmap传入subscriber的回调方法中设置bitmap。看到这里，你可能会疑问了，这么一串操作都是在主线程中完成的吗？这还能不ANR?？？其实并不是··关键在于以下两行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subscribeOn(Schedulers.io())</div><div class="line">observeOn(AndroidSchedulers.mainThread())</div></pre></td></tr></table></figure>
<p>这两行代码的作用是切换线程，前者让subscribe过程中发生在子线程中，这里的Schedulers.io()表示的进行io操作的线程调度器，内部实质是线程池。后者是让subscriber的回调过程发生在UI线程中。轻松两行代码就实现了线程间的切换，比起handler来切换线程这样简直不能太方便。</p>
<p>其他使用到RxJava的地方和以上大同小异，无非是从磁盘缓存加载和从内存缓存加载过程的不同，具体的代码逻辑可以参照源码，使用到比较频繁的操作符有：just,from,map,flatmap等，大家可以着重去了解这几个操作符的使用。个人觉得使用RxJava主要还是一个编程思维的转变，概括来说就是“流”，忘记回调，忘记线程，忘记。。。</p>
<p>写完了，请大家批评指正。。</p>
<p>最后贴上源码地址：</p>
<p><a href="https://github.com/geekinpink/ImageLoaderBasedRxjava%20%E6%BA%90%E7%A0%81" target="_blank" rel="external">源码</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/11/用RxJava实现一个ImageLoader/" data-id="cj1d6qeyv0003esqwhp30yocl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-仿网易新闻评论“盖楼”效果" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/11/仿网易新闻评论“盖楼”效果/" class="article-date">
  <time datetime="2017-04-11T06:35:27.731Z" itemprop="datePublished">2017-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/11/仿网易新闻评论“盖楼”效果/">仿网易新闻评论“盖楼”效果实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>各位应该对黄易新闻比较熟悉，其中评论区一般都会出现一些盖楼的神评论，今天的主题就是仿照做一个有盖楼效果的评论列表。</p>
<p>首先上图给大家看下效果：</p>
<p>###</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h5 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><p>首先分析看下评论的结构，仔细观摩下发现，有的评论是简单一条，只有用户头像，昵称，评论内容等；有的评论是回复别人的评论，这样就不只是有用户头像，评论内容等基础信息，还有回复的别人的内容，这就是所谓“盖楼”了。那么怎么设计评论的model可以包含评论的所有数据呢？</p>
<p>首先满足简单评论的model很容易，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Comment &#123;</div><div class="line">    private int id;</div><div class="line">    private String mReplyTime;</div><div class="line">    private String mAvaterUrl;</div><div class="line">    private String mUsername;</div><div class="line">    private String mUserArea;</div><div class="line">    private String mCommentContent;</div><div class="line">    private int mFavorCount;</div><div class="line">    </div><div class="line">    //getter setter</div><div class="line">    ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>以上包括了一条简单评论需要展示项的信息,可视如果是回复其他评论的评论，这种存在“盖楼”的评论项，这种结构就无法满足了。吃根辣条冷静一下，再分析盖楼中的内容，发现盖楼中的一项内容其实是被回复的评论，其中包括了用户昵称，评论内容。<br>总结来说，一条评论中可能包括了另一条评论，那么在Comment中添加一个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private Comment replyTo;</div></pre></td></tr></table></figure>
<p>这个字段保存了其回复的评论，这样就能形成一个类似单向链表的结构了，一条评论项中能够与它回复的评论关联起来，并且能够依次链接，那么所有回复的评论内容都能在链表中找到，结构清晰明了，那么model就已经设计好了。</p>
<h5 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h5><p>很明显这是一个列表结构，最外层咱们可以使用Recyclerview来实现，每个评论项可以使用一个自定义View封装起来，这个自定义View来处理数据和UI的适配。我们来分析下这个View的构成：</p>
<ol>
<li>用户头像，昵称，回复内容等都是基础内容，每个评论项都会展示出这些信息。</li>
<li>有的回复其他评论的评论项中间会多出一个评论“楼层”。</li>
</ol>
<p>这样简单一分析，我们就有了思路了，这个自定义的View可以分解成两个部分，一个部分就是基础信息展示，另个就是评论“楼层”展示。布局文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line"></div><div class="line">    &lt;RelativeLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line"></div><div class="line">        &lt;io.geek.myapplication.view.CircleView2</div><div class="line">            android:id=&quot;@+id/iv_avater&quot;</div><div class="line">            android:layout_width=&quot;50dp&quot;</div><div class="line">            android:layout_height=&quot;50dp&quot;</div><div class="line">            android:layout_alignParentLeft=&quot;true&quot;</div><div class="line">            android:layout_alignParentStart=&quot;true&quot;</div><div class="line">            android:layout_alignParentTop=&quot;true&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/tv_username&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:layout_marginTop=&quot;5dp&quot;</div><div class="line">            android:layout_toRightOf=&quot;@+id/iv_avater&quot;</div><div class="line">            android:text=&quot;Geek&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/tv_user_area&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:layout_below=&quot;@+id/tv_username&quot;</div><div class="line">            android:layout_toEndOf=&quot;@+id/iv_avater&quot;</div><div class="line">            android:layout_toRightOf=&quot;@+id/iv_avater&quot;</div><div class="line">            android:text=&quot;来自火星的网友&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/tv_reply_time&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:layout_alignBottom=&quot;@+id/tv_user_area&quot;</div><div class="line">            android:layout_marginLeft=&quot;5dp&quot;</div><div class="line">            android:layout_marginRight=&quot;5dp&quot;</div><div class="line">            android:layout_marginTop=&quot;5dp&quot;</div><div class="line">            android:layout_toRightOf=&quot;@+id/tv_user_area&quot;</div><div class="line">            android:text=&quot;33分钟前&quot;/&gt;</div><div class="line"></div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/favor_count&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:layout_alignParentRight=&quot;true&quot;</div><div class="line">            android:text=&quot;2896&quot;</div><div class="line">            android:textSize=&quot;8dp&quot;/&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;/RelativeLayout&gt;</div><div class="line"></div><div class="line">    &lt;io.geek.myapplication.comment.CommentFloorView</div><div class="line">        android:id=&quot;@+id/comment_floor&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:visibility=&quot;gone&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/tv_comment_content&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;我只是一个普通的评论。&quot;/&gt;</div><div class="line">&lt;/merge&gt;</div></pre></td></tr></table></figure>
<p><strong>tips：</strong> 使用merge标签能够减少布局层级，减少界面渲染次数，优化性能。</p>
<p>以上是我们自定义CommentItemView的布局文件，现在我们来编写CommentItemView，这个自定义View继承LinearLayout，然后构造方法中初始化各个需要绑定数据的view，暴露一个绑定数据的bind方法，这样就能把数据展示在对应的view上了。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">public class CommentItemView extends LinearLayout &#123;</div><div class="line">    CircleImageView avater;</div><div class="line">    TextView tvUsername;</div><div class="line">    TextView tvUserArea;</div><div class="line">    TextView tvReplyTime;</div><div class="line">    TextView tvFavorCount;</div><div class="line">    CommentFloorView commentFloorView;</div><div class="line">    TextView tvCommentContent;</div><div class="line">    Comment mComment;</div><div class="line"></div><div class="line">    public CommentItemView(Context context) &#123;</div><div class="line">        this(context, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CommentItemView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        this(context, attrs, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CommentItemView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">        this(context, attrs, defStyleAttr, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CommentItemView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;</div><div class="line">        super(context, attrs, defStyleAttr);</div><div class="line"></div><div class="line">        initView(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initView(Context context) &#123;</div><div class="line">        LayoutInflater.from(context).inflate(R.layout.list_item_view_comment, this,true);</div><div class="line">        int padding = getResources().getDimensionPixelOffset(R.dimen.activity_horizontal_margin);</div><div class="line">        setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));</div><div class="line">        setOrientation(VERTICAL);</div><div class="line">        setPadding(padding, padding, padding, padding);</div><div class="line"></div><div class="line">        avater = (CircleImageView) findViewById(R.id.iv_avater);</div><div class="line">        tvUsername = (TextView) findViewById(R.id.tv_username);</div><div class="line">        tvUserArea = (TextView) findViewById(R.id.tv_user_area);</div><div class="line">        tvReplyTime = (TextView) findViewById(R.id.tv_reply_time);</div><div class="line">        commentFloorView = (CommentFloorView) findViewById(R.id.comment_floor);</div><div class="line">        tvCommentContent = (TextView) findViewById(R.id.tv_comment_content);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void bind(Comment comment) &#123;</div><div class="line">        mComment = comment;</div><div class="line">        tvUsername.setText(comment.getUsername());</div><div class="line">        tvUserArea.setText(comment.getUserArea());</div><div class="line">        tvReplyTime.setText(comment.getReplyTime());</div><div class="line">        tvCommentContent.setText(comment.getCommentContent());</div><div class="line">        commentFloorView = (CommentFloorView) findViewById(R.id.comment_floor);</div><div class="line"></div><div class="line">        setupCommentFloorView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void setupCommentFloorView() &#123;</div><div class="line">        List&lt;Comment&gt; replyFloor = getReplyFloor();</div><div class="line">        if (replyFloor != null) &#123;</div><div class="line">            commentFloorView.setVisibility(VISIBLE);</div><div class="line">            commentFloorView.updateData(replyFloor);</div><div class="line">        &#125; else &#123;</div><div class="line">            commentFloorView.setVisibility(GONE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    //通过comment中的replyTo字段找到其回复的评论链，按照回复的顺序排列放入list中</div><div class="line">    private List&lt;Comment&gt; getReplyFloor( ) &#123;</div><div class="line">        List&lt;Comment&gt; floorData = new ArrayList&lt;&gt;();</div><div class="line">        if (mComment == null || mComment.getReplyTo() == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        Comment reply = mComment.getReplyTo();</div><div class="line">        while (reply != null) &#123;</div><div class="line">            floorData.add(reply);</div><div class="line">            reply = reply.getReplyTo();</div><div class="line">        &#125;</div><div class="line">        //按照回复的顺序来排列</div><div class="line">        Collections.reverse(floorData);</div><div class="line">        return floorData;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码结构很简单，没有啥复杂的逻辑，就是一个简单点的封装了各个控件的容器，然后有一个绑定数据的方法。可能你看到一个陌生的view：CommentFloorView，<strong>以下</strong>就是本文需要讲的<strong>重点</strong>！！和唯一的<strong>难点</strong>！！</p>
<p>CommentFloorView也是我们一个自定义view，这个view负责的是评论“楼层”展示的，主体构成是Recylerview，我们来仔细分析下这个评论“楼层”，本质就是一个列表，列表中展示的是评论用户名和评论的内容，如果这个列表超过了一定的数量就会折叠展示，点击展开楼层会全部展示，并且每个项会有边框，并不是简单的每个列表项套一个边框，而是看起来会有层叠效果的边框。通过这样一分析，总结出实现这个view的两个难点：</p>
<ol>
<li>展开和隐藏楼层。</li>
<li>边框的绘制。</li>
</ol>
<ul>
<li><strong>难点一</strong></li>
</ul>
<p>这个recylerview中展示的有两种view，其一就是评论项，其二就是展开/隐藏楼层的按钮。熟悉recylerview功能应该会知道重写adapter中的getItemType方法可以实现这种一个recylerview展示不同的类型item。</p>
<p>首先解析展开和隐藏楼层功能，重写getItemCount方法,代码如下，解析在注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public int getItemCount() &#123;</div><div class="line">    if (hasHideFloor()) &#123;</div><div class="line">        if (isFloorExpanded) &#123;</div><div class="line">            //如果有有隐藏楼层，并且楼层是展开的状态</div><div class="line">            //加的1是因为最后还有一个隐藏楼层的项</div><div class="line">            return mComments.size() + 1;</div><div class="line">        &#125; else &#123;</div><div class="line">            //如果有隐藏楼层，并且没有展开，那么只有4项，分别是第一二项数据，展开楼层按钮和最后一项数据</div><div class="line">            return 4;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        //如果没有隐藏楼层，则返回数据的数量</div><div class="line">        return mComments.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//如果数据量大于一个默认值（这里设定的是5个），那么默认会有隐藏楼层，小于的话就无需隐藏</div><div class="line">private boolean hasHideFloor() &#123;</div><div class="line">    return mComments.size() &gt; EXPAND_LIMIT_COMMENT_COUNT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后重现getItemType方法，只要把逻辑理清楚了其实也很简单，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public int getItemViewType(int position) &#123;</div><div class="line">    if (hasHideFloor()) &#123;</div><div class="line">        if (isFloorExpanded) &#123;</div><div class="line">            if (position == mComments.size()) &#123;</div><div class="line">                //如果有隐藏楼层，并且楼层是展开状态，并且是最后一项，那么返回展开/收起按钮布局ID</div><div class="line">                return R.layout.list_item_hide_expand_floor;</div><div class="line">            &#125; else &#123;</div><div class="line">                //如果有隐藏楼层，并且楼层是展开状态，不是最后一项，返回评论项布局ID</div><div class="line">                return R.layout.list_item_simple_reply_comment;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (position == EXPAND_FLOOR_ITEM_POSITION) &#123;</div><div class="line">                //如果有隐藏楼层，并且楼层是隐藏状态，并且是指定的展开楼层按钮位置，那么返回展开/收起按钮布局ID</div><div class="line">                return R.layout.list_item_hide_expand_floor;</div><div class="line">            &#125; else &#123;</div><div class="line">                //如果有隐藏楼层，并且楼层是隐藏状态，不是展开楼层按钮位置，那么评论项布局ID</div><div class="line">                return R.layout.list_item_simple_reply_comment;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        //如果没有隐藏楼层，那么都是返回评论布局ID</div><div class="line">        return R.layout.list_item_simple_reply_comment;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重写好了以上两个方法，就能配合onCreateViewHolder和onBindViewHolder方法来实现列表中不同位置生成不同的View，并且绑定响应的数据项。</p>
<p>这样就能实现UI效果了，但是有个棘手的问题来了，怎么做到点击展开/隐藏楼层后真的能展开和隐藏部分item呢？不要慌，吃根辣条冷静分析下，我们已经重写了getItemCount和getItemType方法，判断逻辑中有利用判定楼层展开和隐藏的字段isFloorExpaned来返回不同的item个数和控制在不同位置返回不同的view，其实实现展开和隐藏楼层的核心部分就写完了，现在我们只需要控制这个isFloorExpanded字段的值就行了，具体实现就是编写一个监听点击展开/隐藏楼层按钮的接口，然后在adapter构造方法中创建一个监听器，传入到展开/隐藏楼层按钮的ViewHolder中，在点击这个view的时候触发监听器，修改isFloorExpanded方法，并且notifyDataSetChanged()方法，重新刷新recylerview。核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">//这个adapter是编写在CommentFloorView中的，所以使用了static来修饰</div><div class="line">public static class CommentFloorAdapter extends RecyclerView.Adapter &#123;</div><div class="line">       private List&lt;Comment&gt; mComments = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">       private OnFloorExpandListener mOnFloorExpandListener;</div><div class="line">       private boolean isFloorExpanded;</div><div class="line"></div><div class="line">       public CommentFloorAdapter() &#123;</div><div class="line">           mOnFloorExpandListener = new OnFloorExpandListener() &#123;</div><div class="line">               @Override</div><div class="line">               public void onFloorExpand(boolean isExpand) &#123;</div><div class="line">                   isFloorExpanded = isExpand;</div><div class="line">                   notifyDataSetChanged();</div><div class="line">               &#125;</div><div class="line">           &#125;;</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">     </div><div class="line"></div><div class="line">      //.....</div><div class="line"></div><div class="line">       public interface OnFloorExpandListener &#123;</div><div class="line">           void onFloorExpand(boolean isExpand);</div><div class="line">       &#125;</div><div class="line"></div><div class="line"></div><div class="line">       static class HideExpandFloorVH extends RecyclerView.ViewHolder &#123;</div><div class="line">           FrameLayout mContentView;</div><div class="line">           TextView tips;</div><div class="line">           OnFloorExpandListener mOnFloorExpandListener;</div><div class="line"></div><div class="line">           public HideExpandFloorVH(View itemView, OnFloorExpandListener onFloorExpandListener, final boolean isFloorExpanded) &#123;</div><div class="line">               super(itemView);</div><div class="line">               mOnFloorExpandListener = onFloorExpandListener;</div><div class="line">               mContentView = (FrameLayout) itemView;</div><div class="line">               tips = (TextView) mContentView.findViewById(R.id.tv_is_show_all);</div><div class="line"></div><div class="line">               mContentView.setOnClickListener(new OnClickListener() &#123;</div><div class="line">                   @Override</div><div class="line">                   public void onClick(View v) &#123;</div><div class="line">                       mOnFloorExpandListener.onFloorExpand(!isFloorExpanded);</div><div class="line">                   &#125;</div><div class="line">               &#125;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           public void changeTips(boolean isFloorExpanded) &#123;</div><div class="line">               tips.setText(isFloorExpanded ? &quot;收起展开楼层&quot; : &quot;展开隐藏楼层&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>tips:</strong>内部类最好使用static修饰，这样内部类不会持有外部类的强应用，防止内存泄露，优化性能。</p>
<p>这样核心的功能就已经实现啦~此时的实现效果如下图：</p>
<p>这样看着和原版的还是有点差距的，这是没有绘制边框的原因，吃根辣条休息下，接下来开始解析难点二了。</p>
<ul>
<li><strong>难点二</strong></li>
</ul>
<p>还是先要分析下这个边框是个啥玩意，看着是有层叠的效果。细细看了下，发现它的规律是第一个绘制一个边框，然后第一个和第二个作为整体外层再绘制一个边框，再前三个作为一个整体绘制边框，依次类推。这样就产生了一种层叠的效果。绘制的规律被我们发现了，那具体如何绘制呢？recyclerview中有一个方法是addItemDecoration，利用ItemDecoration我们可以给每个item绘制边框或者分割线，这里我们定义一个CommentFloorItemDecoration类，继承自ItemDecoration，重写其中的onDraw和getItemOffsets方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">public class CommentFloorItemDecoration extends RecyclerView.ItemDecoration &#123;</div><div class="line">    private static float BORDER_OFFSET;</div><div class="line">    private static float BORDER_WIDTH;</div><div class="line">    private Context mContext;</div><div class="line">    private Paint mBorderPaint;</div><div class="line"></div><div class="line">    public CommentFloorItemDecoration(Context context) &#123;</div><div class="line">        mContext = context;</div><div class="line"></div><div class="line">        BORDER_OFFSET = context.getResources().getDisplayMetrics().density * 1;</div><div class="line">        BORDER_WIDTH = context.getResources().getDisplayMetrics().density * 1;</div><div class="line">        mBorderPaint = new Paint();</div><div class="line">        mBorderPaint.setAntiAlias(true);</div><div class="line">        mBorderPaint.setColor(Color.LTGRAY);</div><div class="line">        mBorderPaint.setStyle(Paint.Style.STROKE);</div><div class="line">        mBorderPaint.setStrokeWidth(BORDER_WIDTH);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;</div><div class="line">        int itemCount = parent.getChildCount();</div><div class="line"></div><div class="line">        int top = parent.getChildAt(0).getTop();</div><div class="line">        for (int i = 0; i &lt; itemCount; i++) &#123;</div><div class="line">            View child = parent.getChildAt(i);</div><div class="line">            int left = child.getLeft();</div><div class="line">            int right = child.getRight();</div><div class="line">            int bottom = child.getBottom();</div><div class="line">            c.drawRect(left, top, right, bottom, mBorderPaint);</div><div class="line">            top -= (BORDER_WIDTH + BORDER_OFFSET);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123;</div><div class="line">        super.getItemOffsets(outRect, view, parent, state);</div><div class="line"></div><div class="line"></div><div class="line">        RecyclerView.Adapter adapter = parent.getAdapter();</div><div class="line">        int itemCount = adapter.getItemCount();</div><div class="line">        int i = parent.getChildAdapterPosition(view);</div><div class="line">        int top = (int) ((itemCount - i) * BORDER_WIDTH + (itemCount - i - 1) * BORDER_OFFSET);</div><div class="line">        int left = top;</div><div class="line">        int right = top;</div><div class="line">        int bottom = (int) BORDER_WIDTH;</div><div class="line">        if (i == 0) &#123;</div><div class="line">            outRect.set(left, top, right, bottom);</div><div class="line">        &#125; else &#123;</div><div class="line">            outRect.set(left, 0, right, bottom);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getItemOffset的作用是得到每个item的偏移量，重写此方法可以给每个item设置偏移量，在这里我们按照上面总结出的规律给不同的item设置的不同的offset值，然后再重写onDraw方法，给item绘制边框，具体逻辑参看代码。最后我们就完整实现盖楼效果了。</p>
<p>全文就此完毕~（ <strong>注意：</strong> 此文主要是提供一个思路，和原版细节方面有一定出入，并且没有运用到实际项目中过，需要使用的同学请自行测试）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/11/仿网易新闻评论“盖楼”效果/" data-id="cj1d6qeyt0002esqw3otqae7h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Recyclerview加载更多功能实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/11/Recyclerview加载更多功能实现/" class="article-date">
  <time datetime="2017-04-11T06:35:05.435Z" itemprop="datePublished">2017-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/11/Recyclerview加载更多功能实现/">RecyclerView加载更多功能实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>2017.3.20更新</strong><br>-<br><strong>更新说明</strong>：之前看评论里的童鞋们给我反映问题，很感谢大家指出，针对出现的问题我进行了一些改进。同时将加载更多的这个功能从主体的adapter中分离出来，使用了装饰者模式，降低了代码的耦合，这样便于维护和修改。</p>
<p>装饰者模式是常用的Java设计模式之一，不熟悉的童鞋可以自行查阅资料，先了解了装饰者模式看以下内容会容易懂一点~这个设计模式在Android里也是广泛应用，最典型的就是Context的应用了。</p>
<p>……………………….我是分割线…………………………………………</p>
<p>Recyclerview是 Listview 的升级版本，在项目中使用较为广泛，官方也推荐我们使用 Recyclerview 来代替 Listview，在此就不多说 Recyclerview 的优势特点 balala了。。。</p>
<p>在实际项目中，列表通常是分页的，请求服务器也只会一次请求若干条，按需加载，这样比较节省流量，这样就有了我们很常见的上拉加载更多的功能，具体的实现效果如下图：</p>
<p><img src="http://img.blog.csdn.net/20160401002049247" alt="这里写图片描述"></p>
<p>该activity的布局文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</div><div class="line">    android:id=&quot;@+id/activity_main&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;</div><div class="line">    tools:context=&quot;io.geek.myapplication.MainActivity&quot;&gt;</div><div class="line"></div><div class="line">    &lt;android.support.v7.widget.RecyclerView</div><div class="line">        android:id=&quot;@+id/recycler&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;/&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<p>底部加载更多的view布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">              android:orientation=&quot;horizontal&quot;</div><div class="line">              android:layout_width=&quot;match_parent&quot;</div><div class="line">              android:gravity=&quot;center&quot;</div><div class="line">              android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line"></div><div class="line">    &lt;ProgressBar</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:text=&quot;正在加载...&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<p>底部提示到底的view布局:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">              android:orientation=&quot;horizontal&quot;</div><div class="line">              android:layout_width=&quot;match_parent&quot;</div><div class="line">              android:padding=&quot;8dp&quot;</div><div class="line">              android:gravity=&quot;center&quot;</div><div class="line">              android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:text=&quot;已经到底了&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<p>数据item的view：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">              xmlns:tools=&quot;http://schemas.android.com/tools&quot;</div><div class="line">              android:orientation=&quot;horizontal&quot;</div><div class="line">              android:gravity=&quot;center&quot;</div><div class="line">              android:padding=&quot;8dp&quot;</div><div class="line">              android:layout_width=&quot;match_parent&quot;</div><div class="line">              android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line"></div><div class="line">    &lt;View</div><div class="line">        android:background=&quot;@color/colorAccent&quot;</div><div class="line">        android:layout_width=&quot;50dp&quot;</div><div class="line">        android:layout_height=&quot;50dp&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:gravity=&quot;center&quot;</div><div class="line">        android:id=&quot;@+id/tv_content&quot;</div><div class="line">        tools:text=&quot;我是第一项&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<p>接下来就是代码的编写了，开头就已经讲到过我们在这要用到装饰者模式，其实装饰者模式并没有多么复杂，可以理解成给一个类装饰点新功能，并且不会影响到这个类本来的功能。装饰者模式写法也很简单，分为以下几步套路：</p>
<h4 id="1-装饰者模式套路第一步："><a href="#1-装饰者模式套路第一步：" class="headerlink" title="1. 装饰者模式套路第一步："></a>1. 装饰者模式套路第一步：</h4><p><strong>创建基类</strong>（装饰类和被装饰类共同父类），首先写一个抽象类BaseAdapter，继承自RecyclerView.Adapter，这个Adapter中只封装了与数据源相关的字段和方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 与数据源相关的字段和方法封装在父类中</div><div class="line"> */</div><div class="line"></div><div class="line">public abstract class BaseAdapter&lt;T&gt; extends RecyclerView.Adapter &#123;</div><div class="line">    protected List&lt;T&gt; dataSet = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"></div><div class="line">    public void updateData(List dataSet) &#123;</div><div class="line">        this.dataSet.clear();</div><div class="line">        appendData(dataSet);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void appendData(List dataSet) &#123;</div><div class="line">        if (dataSet != null &amp;&amp; !dataSet.isEmpty()) &#123;</div><div class="line">            this.dataSet.addAll(dataSet);</div><div class="line">            notifyDataSetChanged();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;T&gt; getDataSet() &#123;</div><div class="line">        return dataSet;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getItemCount() &#123;</div><div class="line">        return dataSet.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-装饰者模式套路第二步"><a href="#2-装饰者模式套路第二步" class="headerlink" title="2. 装饰者模式套路第二步"></a>2. 装饰者模式套路第二步</h4><p><strong>创建装饰类</strong>，然后开始编写加载更多的adapter的包装类，这个类继承自BaseAdpater，这个装饰类中只负责处理加载更多的逻辑，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 在这个装饰器中，只做与加载更多相关操作。</div><div class="line"></div><div class="line">public class LoadMoreAdapterWrapper extends BaseAdapter&lt;String&gt; &#123;</div><div class="line">    private BaseAdapter mAdapter;</div><div class="line">    private static final int mPageSize = 10;</div><div class="line">    private int mPagePosition = 0;</div><div class="line">    private boolean hasMoreData = true;</div><div class="line">    private OnLoad mOnLoad;</div><div class="line"></div><div class="line">    public LoadMoreAdapterWrapper(BaseAdapter adapter, OnLoad onLoad) &#123;</div><div class="line">        mAdapter = adapter;</div><div class="line">        mOnLoad = onLoad;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        if (viewType == R.layout.list_item_no_more) &#123;</div><div class="line">            View view = LayoutInflater.from(parent.getContext()).inflate(viewType, parent, false);</div><div class="line">            return new NoMoreItemVH(view);</div><div class="line">        &#125; else if (viewType == R.layout.list_item_loading) &#123;</div><div class="line">            View view = LayoutInflater.from(parent.getContext()).inflate(viewType, parent, false);</div><div class="line">            return new LoadingItemVH(view);</div><div class="line">        &#125; else &#123;</div><div class="line">            return mAdapter.onCreateViewHolder(parent, viewType);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123;</div><div class="line">        if (holder instanceof LoadingItemVH) &#123;</div><div class="line">            requestData(mPagePosition, mPageSize);</div><div class="line">        &#125; else if (holder instanceof NoMoreItemVH) &#123;</div><div class="line"></div><div class="line">        &#125; else &#123;</div><div class="line">            mAdapter.onBindViewHolder(holder, position);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void requestData(int pagePosition, int pageSize) &#123;</div><div class="line"></div><div class="line">        //网络请求,如果是异步请求，则在成功之后的回调中添加数据，并且调用notifyDataSetChanged方法，hasMoreData为true</div><div class="line">        //如果没有数据了，则hasMoreData为false，然后通知变化，更新recylerview</div><div class="line"></div><div class="line">        if (mOnLoad != null) &#123;</div><div class="line">            mOnLoad.load(pagePosition, pageSize, new ILoadCallback() &#123;</div><div class="line">                @Override</div><div class="line">                public void onSuccess() &#123;</div><div class="line">                    notifyDataSetChanged();</div><div class="line">                    mPagePosition = (mPagePosition + 1) * mPageSize;</div><div class="line">                    hasMoreData = true;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onFailure() &#123;</div><div class="line">                    hasMoreData = false；</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getItemViewType(int position) &#123;</div><div class="line">        if (position == getItemCount() - 1) &#123;</div><div class="line">            if (hasMoreData) &#123;</div><div class="line">                return R.layout.list_item_loading;</div><div class="line">            &#125; else &#123;</div><div class="line">                return R.layout.list_item_no_more;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            return mAdapter.getItemViewType(position);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getItemCount() &#123;</div><div class="line">        return mAdapter.getItemCount() + 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class LoadingItemVH extends RecyclerView.ViewHolder &#123;</div><div class="line"></div><div class="line">        public LoadingItemVH(View itemView) &#123;</div><div class="line">            super(itemView);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class NoMoreItemVH extends RecyclerView.ViewHolder &#123;</div><div class="line"></div><div class="line">        public NoMoreItemVH(View itemView) &#123;</div><div class="line">            super(itemView);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface OnLoad &#123;</div><div class="line">    void load(int pagePosition, int pageSize, ILoadCallback callback);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public interface ILoadCallback &#123;</div><div class="line">    void onSuccess();</div><div class="line"></div><div class="line">    void onFailure();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析如下：</p>
<ol>
<li>该类中的传入的mAdapter就是需要被装饰的adapter，mOnLoad是自定义的一个接口，传入之后可以回调处理加载更多数据。</li>
<li>首先重写getItemCount方法，因为在列表中最后始终会有一个加载更多或者是到底提示的view，所以item的数目始终是数据源的数目多一个。</li>
<li>重写getItemType方法：首先判断position是否是最后一个，如果不是的话，则直接返回被装饰的mAdapter的getItemType；如果是的话判断hasMoreData变量，是true则返回加载更多的布局文件ID，反之返回到底的布局文件ID。这里的hasMoreData是我们自己定义的一个boolean字段，通过改变这个值就可以最后一个view应该是加载更多还是到底。</li>
<li>重写onCreateViewHolder方法，在这个方法中通过判断viewType的类型返回不同的ViewHolder。</li>
<li>重写onBindViewHolder方法，在这个方法中，判断holder的类型的不同做出不同的操作，如果holder是加载更多的holder，那么表示加载更多的view正在展示，这时候就应该做出加载更多的操作，这个操作放在了requestData方法中。</li>
<li>在requestData方法中，触发了OnLoad接口中的load回调，传入的参数有当前的页码加载数据一页的大小，加载完成之后的回调接口，可以看到加载完成之后会进行不同的作，如果成功，则设置hasMoreData为true，并且通知数据发生改变，更新列表，改变前页码；如果失败的话，则把hasMoreData设置为false。</li>
</ol>
<h4 id="3-装饰者模式套路第三步"><a href="#3-装饰者模式套路第三步" class="headerlink" title="3. 装饰者模式套路第三步"></a>3. 装饰者模式套路第三步</h4><p><strong>创建被装饰类</strong>，同样这个类也需要继承自BaseAdapter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * 被装饰类要和装饰类继承自同一父类</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyAdapter extends BaseAdapter&lt;String&gt; &#123;</div><div class="line">    private Context mContext;</div><div class="line"></div><div class="line">    public MyAdapter(Context context) &#123;</div><div class="line">        mContext = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        View v = LayoutInflater.from(mContext).inflate(R.layout.list_item_mine, parent, false);</div><div class="line">        return new MyViewHolder(v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123;</div><div class="line">        ((MyViewHolder) holder).bind(getDataSet().get(position));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    static class MyViewHolder extends RecyclerView.ViewHolder &#123;</div><div class="line">        TextView mTextView;</div><div class="line"></div><div class="line">        public MyViewHolder(View itemView) &#123;</div><div class="line">            super(itemView);</div><div class="line"></div><div class="line">            mTextView = (TextView) itemView.findViewById(R.id.tv_content);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void bind(CharSequence content) &#123;</div><div class="line">            mTextView.setText(content);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-装饰者模式套路第四步"><a href="#4-装饰者模式套路第四步" class="headerlink" title="4. 装饰者模式套路第四步"></a>4. 装饰者模式套路第四步</h4><p>最后一步就是如何<strong>使用</strong>，这个adapter就是一个普通的没有上拉加载功能的adapter，如果要给它加上这个功能，只需要这么使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    RecyclerView mRecyclerView;</div><div class="line">    BaseAdapter mAdapter;</div><div class="line">    int loadCount;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        </div><div class="line">        mRecyclerView = (RecyclerView) findViewById(R.id.recycler);</div><div class="line">        </div><div class="line">        //创建被装饰者类实例</div><div class="line">        final MyAdapter adapter = new MyAdapter(this);</div><div class="line">        //创建装饰者实例，并传入被装饰者</div><div class="line">        mAdapter = new LoadMoreAdapterWrapper(adapter, new OnLoad() &#123;</div><div class="line">            @Override</div><div class="line">            public void load(int pagePosition, int pageSize, final ILoadCallback callback) &#123;</div><div class="line">                //此处模拟做网络操作，2s延迟，将拉取的数据更新到adpter中</div><div class="line">                new Handler().postDelayed(new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">                        List&lt;String&gt; dataSet = new ArrayList();</div><div class="line">                        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">                            dataSet.add(&quot;我是一条数据&quot;);</div><div class="line">                        &#125;</div><div class="line">                        //数据的处理最终还是交给被装饰的adapter来处理</div><div class="line">                        adapter.appendData(dataSet);</div><div class="line">                        callback.onSuccess();</div><div class="line">                        //模拟加载到没有更多数据的情况，触发onFailure</div><div class="line">                        if (loadCount++ == 3) &#123;</div><div class="line">                            callback.onFailure();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;, 2000);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        mRecyclerView.setAdapter(mAdapter);</div><div class="line">        mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就完整实现了 Recylerview 的加载更多功能，使用装饰者模式使得整个代码结构更加清晰，在被装饰的adapter中就不用处理太多逻辑，专心处理数据展示即可，易于维护。</p>
<p>其中比较绕的地方可能就是数据加载的回调接口，不过仔细理一下还是没有多大问题，总体来说还是很简单的，如果还是有不明白的，可能你对 Recylerview 的使用方法还不够了解，可以自行学习。<br>有不当之处请大家批评指正，谢谢：）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/11/Recyclerview加载更多功能实现/" data-id="cj1d6qeyr0001esqwey0x8ds9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android消息机制浅析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/11/Android消息机制浅析/" class="article-date">
  <time datetime="2017-04-11T05:48:26.755Z" itemprop="datePublished">2017-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/11/Android消息机制浅析/">Android消息机制浅析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android中的消息机制一直都是新手头疼的问题，对于Handler机制的理解是Android重中之重，经常在面试和日常开发中遇到，所以，这篇文章是浅析一下Handler机制的原理，再此之前先解决一下新手疑惑的问题，还有为文章后面解析做铺垫。</p>
<p><strong>Handler机制到底干嘛用的？</strong></p>
<p>在实际开发中，最常用到Handler就是切换到UI线程中更新UI，其实Handler不止是更新UI才会用到，对于任何切换线程执行任务都是可以做的。</p>
<p><strong>为什么Android中只能在主线程（UI线程）中更新UI？</strong></p>
<p>Android和通常的GUI程序一样，都是单线程模型的，因为要UI更新效率直接影响到用户体验，所以UI的处理一定要放在第一位。子线程可能造成UI更新发错乱，原因是多个子线程同时对一个UI控件进行操作，结果造成界面更新不符合预期，如果用到上锁机制，你就想想你的代码会有多复杂吧。。而且加锁会影响UI更新效率，所以综上原因，Android只允许你在主线程中更新UI。</p>
<p><strong>Android程序的入口在哪里？</strong></p>
<p>刚学习Java的同学都是从在main方法中写一句System.out.println(“Hello World!”)开始的，而学了Android之后，就有疑问了：Android程序没有main方法吗？？答案肯定是有的，在Android中入口类是ActivityThread，其中main方法就是程序启动时入口方法。</p>
<h2 id="Handler的基本用法"><a href="#Handler的基本用法" class="headerlink" title="Handler的基本用法"></a>Handler的基本用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private TextView mTextView;</div><div class="line">    private Button mButton;</div><div class="line"></div><div class="line">    //点击按钮之后新建一个子线程，发送一个消息到Looper的消息队列中轮循</div><div class="line">    private Runnable mTask = new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            Message message = Message.obtain();</div><div class="line">            message.obj = &quot;Hello World&quot;;</div><div class="line">            mHandler.sendMessage(message);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    //Handler对象，handleMessage方法会在Looper处理到消息时候回调</div><div class="line">    private Handler mHandler = new Handler() &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            mTextView.setText((CharSequence) msg.obj);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initView() &#123;</div><div class="line">        mTextView = (TextView) findViewById(R.id.tv_hello);</div><div class="line">        mButton = (Button) findViewById(R.id.btn_set_text);</div><div class="line"></div><div class="line">        mButton.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                new Thread(mTask).start();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家对以上的操作应该是很熟悉了吧，不熟悉你就要去看看handler怎么使用的文档，再接着看下面的解析。。这就是一个简单的从子线程切换到主线程去更新UI的做法。同时Handler的应用还有HandlerThread，这里就不展开讲了，有兴趣可以自行查看文档。</p>
<h2 id="Handler原理"><a href="#Handler原理" class="headerlink" title="Handler原理"></a>Handler原理</h2><p>下面就开始讲Handler机制的原理了，其实Handler机制由三个类构成，分别是Handler,Looper,MessageQueue。在这里就不贴出流程图了，人觉得流程图并不能完全呈现出其运作原理，而且容易误导你对源码的理解。</p>
<p>接下来开始分别通过分析源码来解析这三个类：</p>
<h3 id="Looper的源码浅析"><a href="#Looper的源码浅析" class="headerlink" title="Looper的源码浅析"></a>Looper的源码浅析</h3><p>Looper中主要需要关注的两个方法是prepare和loop。这个类的主要作用是用来轮询Handler发送的消息，能够使得消息的处理在指定线程中执行，得益于ThreadLocal类。ThreadLocal是一个线程内部数据存储类，有了它就可以在指定的线程中存储数据。</p>
<p>首先来看下Looper的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">        mQueue = new MessageQueue(quitAllowed);</div><div class="line">        mThread = Thread.currentThread();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Looper的构造方法是private修饰的，意味着Looper只能在Looper类中构造，而查看源码发现，Looper的构造只有在prepare方法出现。并且在构造的时候，Looper对象会持有一个MessageQueue的引用，并且记录了当前的线程。下面来看下prepare方法的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">        if (sThreadLocal.get() != null) &#123;</div><div class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">        &#125;</div><div class="line">        sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>prepare()方法很简单，就是创建一个Looper对象，保存在sThreadLocal中，这样Looper对象就和当前的线程关联起来了。</p>
<p>总结来说Looper的创建其实很简单，可以理解为将一个Looper对象存储到当前线程中，不同线程中创建的Looper，通过Looper.myLooper()返回的Looper是不同实例。下面是Looper中的核心方法，loop方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//省略的代码大部分是非逻辑的日志记录相关代码</div><div class="line">    public static void loop() &#123;</div><div class="line"></div><div class="line">    	//省略若干代码</div><div class="line">        for (;;) &#123;</div><div class="line">            Message msg = queue.next(); // queue是当前的消息队列对象，这里可能堵塞线程</div><div class="line">            if (msg == null) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">          </div><div class="line">          	//省略若干代码</div><div class="line">            try &#123;</div><div class="line">                msg.target.dispatchMessage(msg);</div><div class="line">            &#125; finally &#123;</div><div class="line">       			//省略若干代码</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            //省略若干代码</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里的代码也很简单，就是一个死循环，不停从Looper持有的MessageQueue对象中排队出message。然后调用msg.target.despatchMessage(msg)，<strong>注意：这里都是在Looper所在线程中调用的</strong>。msg.target就是发送了这条消息的主人，也就是handler对象，调用dispatchMessage方法就会按照一定的逻辑顺序回调处理信息的方法，具体逻辑下面再讲，这样就讲完了Looper的核心工作原理了，并没有多复杂，当然源码还是看着有点绕的，感兴趣的同学可以去看下源码。</p>
<h3 id="Handler的源码浅析"><a href="#Handler的源码浅析" class="headerlink" title="Handler的源码浅析"></a>Handler的源码浅析</h3><p>Handler的主要作用是发送message和处理message，handler是怎么和looper关联起来的呢，其实就是通过handler的构造方法，其中Handler总共有7个构造方法，最终调用的就是以下两个中的一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public Handler(Looper looper, Callback callback, boolean async) &#123;</div><div class="line">        mLooper = looper;</div><div class="line">        mQueue = looper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">        if (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">            final Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</div><div class="line">                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</div><div class="line">                    klass.getCanonicalName());</div><div class="line">            &#125;</div><div class="line">        </div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        if (mLooper == null) &#123;</div><div class="line">            throw new RuntimeException(</div><div class="line">                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">        &#125;</div><div class="line">        mQueue = mLooper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其实仔细观察可以发现，区别就是有没有传入Looper，没有传入的话，当前Handler中的mLooper默认就是当前线程中的Looper，如果当前线程没有Looper对象就会抛出异常。因此，handler必须是要有looper关联着的，缺少了Looper的Handler是不能工作的。</p>
<p>我们刚学习handler用法的时候都是从sendMessage(msg)开始的，其实handler发送message的方式有很多，比如post，postDelay，sendMessageAtTime等等···其实不论是以什么样的形式发送的消息，最后都是调用了enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)方法，这个方法再调用了消息队列的中的enqueueMessage(Message msg, long when)方法，这样就将该消息放入消息队列中排队了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">        msg.target = this;</div><div class="line">        if (mAsynchronous) &#123;</div><div class="line">            msg.setAsynchronous(true);</div><div class="line">        &#125;</div><div class="line">        return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面讲过了，在Looper的loop方法中，如果轮询当一条消息时会调用发送该消息的dispatchMessage方法，这样就分发了该消息交给handler来处理，dispatchMessage有一定的分发逻辑，我们来看代码分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">        if (msg.callback != null) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (mCallback != null) &#123;</div><div class="line">                if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>首先判断msg是否存在callback，如果存在就是调用该callback(Runnable对象)的run方法；否则先判断该handler的mCallback是否为空，如果不为空，则调用它的handleMessage方法，如果它的handleMessage返回false，则还会调用handler中的handleMessage方法；如果其返回了true，则不会调用handler中的handleMessage方法；如果mCallback为空，那也只会调用handler中的handleMessage方法。感觉很绕是吧···最好还是自己画一个流程图，这样就能清楚知道这个逻辑了。为毛弄这么复杂的逻辑呢？其实这样就满足你的多种体位，啊，呸··满足你的多种实现方式，比如能message多次分发，比如这种写法：</p>
<pre><code>private Handler mHandler = new Handler(new Handler.Callback() {
    @Override
    public boolean handleMessage(Message msg) {
        Log.d(TAG, &quot;首先回调此方法 &quot; + msg.obj);
        return false;
    }
}) {
    @Override
    public void handleMessage(Message msg) {
        Log.d(TAG, &quot;然后后回调此方法 &quot; + msg.obj);
    }
};
</code></pre><p>这样的写法既给handler传入了一个callback又重载了其handleMessage方法，只要callback中的handleMessage返回为false，表示不拦截信息，就会继续分发消息，最终调用handler的handleMessage方法。handler主要要关注的核心原理就在此，其他细节部分就省略不讲了，自己可以尝试看源码学习。</p>
<h3 id="MessageQueue的源码浅析"><a href="#MessageQueue的源码浅析" class="headerlink" title="MessageQueue的源码浅析"></a>MessageQueue的源码浅析</h3><p>MessageQueue顾名思义，消息队列，这是一个用单链表实现的队列结构，作用就是存储排队进来的消息，主要的操作就是插入和移除，分别对应了enqueueMessage(Message msg, long when)和next()方法。下面贴出代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">boolean enqueueMessage(Message msg, long when) &#123;</div><div class="line">        if (msg.target == null) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class="line">        &#125;</div><div class="line">        if (msg.isInUse()) &#123;</div><div class="line">            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            if (mQuitting) &#123;</div><div class="line">                IllegalStateException e = new IllegalStateException(</div><div class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class="line">                Log.w(TAG, e.getMessage(), e);</div><div class="line">                msg.recycle();</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.markInUse();</div><div class="line">            msg.when = when;</div><div class="line">            Message p = mMessages;</div><div class="line">            boolean needWake;</div><div class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class="line">                // New head, wake up the event queue if blocked.</div><div class="line">                msg.next = p;</div><div class="line">                mMessages = msg;</div><div class="line">                needWake = mBlocked;</div><div class="line">            &#125; else &#123;</div><div class="line">                // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class="line">                // up the event queue unless there is a barrier at the head of the queue</div><div class="line">                // and the message is the earliest asynchronous message in the queue.</div><div class="line">                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class="line">                Message prev;</div><div class="line">                for (;;) &#123;</div><div class="line">                    prev = p;</div><div class="line">                    p = p.next;</div><div class="line">                    if (p == null || when &lt; p.when) &#123;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                        needWake = false;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                msg.next = p; // invariant: p == prev.next</div><div class="line">                prev.next = msg;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // We can assume mPtr != 0 because mQuitting is false.</div><div class="line">            if (needWake) &#123;</div><div class="line">                nativeWake(mPtr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>实质上enqueueMessage就是一个单链表插入的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">Message next() &#123;</div><div class="line">        // Return here if the message loop has already quit and been disposed.</div><div class="line">        // This can happen if the application tries to restart a looper after quit</div><div class="line">        // which is not supported.</div><div class="line">        final long ptr = mPtr;</div><div class="line">        if (ptr == 0) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int pendingIdleHandlerCount = -1; // -1 only during first iteration</div><div class="line">        int nextPollTimeoutMillis = 0;</div><div class="line">       </div><div class="line">        for (;;) &#123;</div><div class="line">            if (nextPollTimeoutMillis != 0) &#123;</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">            synchronized (this) &#123;</div><div class="line">                // Try to retrieve the next message.  Return if found.</div><div class="line">                final long now = SystemClock.uptimeMillis();</div><div class="line">                Message prevMsg = null;</div><div class="line">                Message msg = mMessages;</div><div class="line">                if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class="line">                    // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class="line">                    do &#123;</div><div class="line">                        prevMsg = msg;</div><div class="line">                        msg = msg.next;</div><div class="line">                    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class="line">                &#125;</div><div class="line">                if (msg != null) &#123;</div><div class="line">                    if (now &lt; msg.when) &#123;</div><div class="line">                        // Next message is not ready.  Set a timeout to wake up when it is ready.</div><div class="line">                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        // Got a message.</div><div class="line">                        mBlocked = false;</div><div class="line">                        if (prevMsg != null) &#123;</div><div class="line">                            prevMsg.next = msg.next;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            mMessages = msg.next;</div><div class="line">                        &#125;</div><div class="line">                        msg.next = null;</div><div class="line">                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class="line">                        msg.markInUse();</div><div class="line">                        return msg;</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    // No more messages.</div><div class="line">                    nextPollTimeoutMillis = -1;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Process the quit message now that all pending messages have been handled.</div><div class="line">                if (mQuitting) &#123;</div><div class="line">                    dispose();</div><div class="line">                    return null;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // If first time idle, then get the number of idlers to run.</div><div class="line">                // Idle handles only run if the queue is empty or if the first message</div><div class="line">                // in the queue (possibly a barrier) is due to be handled in the future.</div><div class="line">                if (pendingIdleHandlerCount &lt; 0</div><div class="line">                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</div><div class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">                &#125;</div><div class="line">                if (pendingIdleHandlerCount &lt;= 0) &#123;</div><div class="line">                    // No idle handlers to run.  Loop and wait some more.</div><div class="line">                    mBlocked = true;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (mPendingIdleHandlers == null) &#123;</div><div class="line">                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</div><div class="line">                &#125;</div><div class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Run the idle handlers.</div><div class="line">            // We only ever reach this code block during the first iteration.</div><div class="line">            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">                final IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">                mPendingIdleHandlers[i] = null; // release the reference to the handler</div><div class="line"></div><div class="line">                boolean keep = false;</div><div class="line">                try &#123;</div><div class="line">                    keep = idler.queueIdle();</div><div class="line">                &#125; catch (Throwable t) &#123;</div><div class="line">                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (!keep) &#123;</div><div class="line">                    synchronized (this) &#123;</div><div class="line">                        mIdleHandlers.remove(idler);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Reset the idle handler count to 0 so we do not run them again.</div><div class="line">            pendingIdleHandlerCount = 0;</div><div class="line"></div><div class="line">            // While calling an idle handler, a new message could have been delivered</div><div class="line">            // so go back and look again for a pending message without waiting.</div><div class="line">            nextPollTimeoutMillis = 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>next方法是一个死循环，所以在调用next方法的时候，如果消息队列中没有消息的话就会堵塞，如果有消息进入就会移除该消息。</p>
<p>以上就是handler机制的整个流程解析，其实把核心内容拿出来其实还是很容易理解的。</p>
<h2 id="UI线程中的Looper创建过程"><a href="#UI线程中的Looper创建过程" class="headerlink" title="UI线程中的Looper创建过程"></a>UI线程中的Looper创建过程</h2><p>大家在使用handler时，大多会直接在UI线程中直接new Handler()，并没有传入looper对象，为什么可以依然运行呢？其实上面就讲到了，没有传入looper给handler的时候，构造方法会默认传入当前线程中的looper对象给handler，那说明UI线程中默认给我们提供了一个looper对象，那这个looper对象是在哪里创建的呢？其实就是在程序入口ActivityThread的main方法中，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">     </div><div class="line"></div><div class="line">     	//.....</div><div class="line">        Looper.prepareMainLooper();</div><div class="line"></div><div class="line">        ActivityThread thread = new ActivityThread();</div><div class="line">        thread.attach(false);</div><div class="line"></div><div class="line">        if (sMainThreadHandler == null) &#123;</div><div class="line">            sMainThreadHandler = thread.getHandler();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // if (false) &#123;</div><div class="line">        //     Looper.myLooper().setMessageLogging(new</div><div class="line">        //             LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</div><div class="line">        // &#125;</div><div class="line"></div><div class="line">        // End of event ActivityThreadMain.</div><div class="line">  </div><div class="line">  		//.....</div><div class="line">        Looper.loop();</div><div class="line"></div><div class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看出来，在UI线程中，首先调用了Looper的prepareMainLooper方法，其实就是给UI线程关联一个looper对象，并且记录到Looper中的sMainLooper中了，然后调用了Looper.loop()方法，开始轮询消息，这里loop方法会堵塞线程，如果looper意外停止工作则会抛出异常。</p>
<p>在此Android消息机制浅析结束，希望能帮助到一些初学者，如果文中有误请大家指出，谢谢~~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/11/Android消息机制浅析/" data-id="cj1d6qeym0000esqwpws0yvdr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/11/用RxJava实现一个ImageLoader/">用RxJava实现一个ImageLoader</a>
          </li>
        
          <li>
            <a href="/2017/04/11/仿网易新闻评论“盖楼”效果/">仿网易新闻评论“盖楼”效果实现</a>
          </li>
        
          <li>
            <a href="/2017/04/11/Recyclerview加载更多功能实现/">RecyclerView加载更多功能实现</a>
          </li>
        
          <li>
            <a href="/2017/04/11/Android消息机制浅析/">Android消息机制浅析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>